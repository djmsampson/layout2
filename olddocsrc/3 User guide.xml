<?xml version="1.0"?>
<!DOCTYPE xsl:stylesheet [
  <!ENTITY nl "&#10;">
  <!ENTITY nbsp "&#160;">
  <!ENTITY sq "&#x25A1;">
  ]>

<doc name="User guide" 
     type="Chapter"
     briefdescription="Describes how to use these tools">
    <para>
        This chapter describes the purpose and overall design of the layout
        tools that the toolbox provides. It also provides some examples of
        creating some user interfaces using layouts.
    </para>

    <!-- ****************************************************************** -->
        <section name="Understanding layouts">
            <p>The purpose of a "layout" is to manage the positioning of one
                or more user-interface components. This means that instead of
                worrying about the exact position of each user interface component
                you instead worry about the relative positioning of them; are they
            arranged in a vertical list, horizontal list, a grid pattern, etc.</p>
        <p>The best way to understand what layouts are and why they are a good user-interface
            design tool is to see some examples. The sections below go through the
            basics of building an interface using layouts and how to build complex
        interfaces using them.</p>
            
            <subsection name="Layout basics">
                <p>To see how layouts work, let's use the most basic layout,
                    a horizontal list (or box). We first create a window:</p>
                    <example>
                        <code>f = <matlabfcn>figure</matlabfcn>();</code>
                    </example>

                <p>Now let's create the horizontal layout and add it to the figure. Note
                that in common with other MATLAB graphics objects, one object is added to
                another by setting the <code>Parent</code> property - this will automatically 
                adjust the list of <code>Children</code> in the parent object. The job of a 
                horizontal box layout is to arrange its contents in a horizontal line, 
                setting the position of each element to best fill the space:</p>
                <example>
                        <code>layout = <fcnref>uix.HBox</fcnref>( 'Parent', f );</code>
                </example>
                <p>Nothing's changed! That's because the layout is for arranging
            other user-interface components - it doesn't draw anything itself. Let's
        add some buttons. Note how after creating each button the existing contents
    of the box make room for the new addition; we don't need to set the position of
    any user-interface component!</p>
                <example>
                        <code><matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 1', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 2', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 3', 'Parent', layout );</code>
                <result><center><img src="Images/basics_example2.png"/>.<img src="Images/basics_example3.png"/>.<img src="Images/basics_example4.png"/></center></result>
</example>
                <p>Other layouts work in exactly the same way, although visually
            the end-result is quite different:</p>
                <example>
                        <code>f = <matlabfcn>figure</matlabfcn>();
layout = <fcnref>uix.VBox</fcnref>( 'Parent', f );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 1', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 2', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 3', 'Parent', layout );</code>
                <result><center><img src="Images/basics_example_vbox.png"/></center></result>
                </example>
                <example>
                <code>f = <matlabfcn>figure</matlabfcn>();
layout = <fcnref>uix.TabPanel</fcnref>( 'Parent', f );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 1', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 2', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 3', 'Parent', layout );</code>
                <result><center><img src="Images/basics_example_tab.png"/></center></result>
                </example>
                
            </subsection>
            
  <subsection name="Types of layout">
      <p>The layouts in this toolbox come in three forms:</p>
      <ol>
          <li><b>Panels</b>: show a single child element with some decoration. Other children
          of the layout are hidden from view. The visible child can be switched. Available
          panels include 
          <ref link="uix.Panel">Panel</ref>,
          <ref link="uix.CardPanel">CardPanel</ref>,
          <ref link="uix.BoxPanel">BoxPanel</ref>,
          <ref link="uix.TabPanel">TabPanel</ref> and
          <ref link="uix.ScrollingPanel">ScrollingPanel</ref>. </li>
          
          <li><b>Boxes</b>: arrange children linearly in a single row or column. Available boxes include
          <ref link="uix.HBox">HBox</ref>,
          <ref link="uix.VBox">VBox</ref>,
          <ref link="uix.HBoxFlex">HBoxFlex</ref> and
          <ref link="uix.VBoxFlex">VBoxFlex</ref>. </li>
          
          <li><b>Grids</b>: (also known as tables) arrange children in a two-dimensional grid. Available grids include
          <ref link="uix.Grid">Grid</ref> and
          <ref link="uix.GridFlex">GridFlex</ref>. </li>
          
      </ol>
</subsection>

            <subsection name="Sizes and units">
                <p>In the previous section we noted that when using layouts
                    you never need to set the position or size of a user-interface
                    component yourself - the layouts take care of it. So how do
                you control the sizes of the components?</p>
                <p>Each layout that arranges multiple items within its drawing area
                    has a sizing property: for horizontal boxes this is <code>Widths</code> 
                    and for vertical boxes <code>Heights</code>; for grids we have both <code>Widths</code>
                and <code>Heights</code>. These all obey the same convention:</p>
                <ol>
                    <li>Positive numbers indicate sizes in pixels (similar to "pixel" units)</li>
                    <li>Negative numbers indicate a weighting for variable sizing (similar to "normalized" units)</li>
                </ol>
                <p>By default all sizes are set to -1 (variable size with unit weighting).</p>
                <p>Let's take a simple example:</p>
                <example>
                <code>f = <matlabfcn>figure</matlabfcn>();
layout = <fcnref>uix.HBox</fcnref>( 'Parent', f );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 1', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 2', 'Parent', layout );
<matlabfcn>uicontrol</matlabfcn>( 'String', 'Button 3', 'Parent', layout );</code>
                <result><center><img src="Images/basics_example4.png"/></center></result>
</example>
                <p>We can set the middle element to be twice as wide as the others
            (but still variable width) by setting its weight to -2 with the others at -1:</p>
                <example>
                    <code>layout.Widths = [-1 -2 -1]</code>
                <result><center><img src="Images/basics_example5.png"/></center></result>
</example>
                <p>Alternatively we might want the first element to have a 
                fixed width of 100 pixels with the others filling any remaining 
                space equally:</p>
                <example>
                <code>layout.Widths = [100 -1 -1]</code>
                <result><center><img src="Images/basics_example6.png"/></center></result>
</example>

                <p>This ability to mix fixed and variable sized elements is
            crucial in interface design. It really comes into its own when building
        a hierarchy of layouts, described next.</p>
                
            <subsubsection name="Minimum sizes">
                <p>Many of the multi-element layouts also provide a <code>MinimumWidths</code>
                    or <code>MinimumHeights</code>
                    property to prevent an element becoming too small. This is measured in
                    pixels and defaults to one pixel. Take care to ensure that the available 
                    space is at least the sum of the minimum sizes, plus any padding and 
                    spacing.</p>
            </subsubsection>
        
            </subsection>
            
            <subsection name="Layout hierarchies">
                <p>Consider the following simple interface:</p>
                <center><img src="Images/why_layout1.png"/></center>
                <p>Instead of thinking of this in terms of three elements that need
                    positioning, we can break it up into two simple linear ("box") arrangements:
                    a vertical box with the axes at the top and a control area at the bottom and
                a horizontal box containing two buttons:</p>
                <center><img src="Images/why_layout_anno1.png"/>.<img src="Images/why_layout_anno2.png"/></center>
                <p>By placing the second layout (horizontal box) inside the first (vertical box)
                    we arrive at the complete layout. Since the sizes of the elements in each list
                    can be set to be fixed or flexible we can achieve a user-interface that is not just
                arranged correctly when created, but also behaves well when resized.</p>
                <center><img src="Images/why_layout2.png"/></center>
                <p>Note that the buttons have stayed fixed height as the window grows and the
                axes grow to fill the remaining space.</p>
                
                <subsubsection name="Code:" staticref="HierarchyExample">
                <p>The example above can be created programmically pretty 
                much as described in text 
                (the completed example code is here: 
                [ <a href="Examples/hierarchyexample.m">view</a>
                | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','hierarchyexample.m'))">edit</a>
                | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); hierarchyexample; cd(p)">run</a> ]
                )</p>
                <p><b>1. Open a window</b></p>
                <example><code>f = <matlabfcn>figure</matlabfcn>( 'Position', 200*ones(1,4) );</code></example>
                <p><b>2. Create the first layout (vertical box)</b><br/>Inside this vertical box
            we place the axes</p>
            <example><code>vbox = <fcnref>uix.VBox</fcnref>( 'Parent', f );
axes( 'Parent', vbox );</code>
                <result><center><img src="Images/why_layout0_1.png"/></center></result>
                </example>
                <p><b>3. Create the second layout (horizontal box)</b><br/>Inside this horizontal box
            we place two buttons</p>
<example><code>hbox = <fcnref>uix.HButtonBox</fcnref>( 'Parent', vbox, 'Padding', 5 );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', hbox, ...
    'String', 'Button 1' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', hbox, ...
    'String', 'Button 2' );</code>
                <result><center><img src="Images/why_layout0_2.png"/></center></result>
                </example>
    <p><b>4. Set the sizes</b><br/>We want the axes to grow with the window so
    set the first size to be -1 (which means variable size with wieght 1) and the buttons to stay fixed height so set the
second size to 35 (fixed height of 35 pixels)</p>
<example><code>set( vbox, 'Heights', [-1 35] )</code>
                <result><center><img src="Images/why_layout1.png"/></center></result>
                </example>
</subsubsection>
</subsection>
        <subsection name="Why use layouts?">
            <p>MATLAB ships with a GUI design tool called <matlabfcn>GUIDE</matlabfcn>. This
        doesn't use layouts, but forces users to manually position each element. This approach
    is a much faster way to build simple user-interfaces, so why would you want to
use layouts?</p>
            <p>The over-riding reason for using layouts or layout managers is
            to gain control of the resizing behaviour of the interface without
            having to write a complex "ResizeFcn". If you simply position user-interface elements
            directly (either using <matlabfcn>GUIDE</matlabfcn> or programmatically), you
            have two choices about what happens when the window resizes:
            </p>
                <examples>
                    <example>
                        <description><b>1. The user-interface components scale with the window (normalised units)</b><br/>We didn't really want the buttons to grow but everything resizes in proportion.</description>
                        <code>f = <matlabfcn>figure</matlabfcn>( 'Position', 200*ones(1,4) );
<matlabfcn>axes</matlabfcn>( 'Parent', f, ...
    'Units', 'Normalized', ...
    'OuterPosition', [0.02 0.2 0.96 0.8] );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', f, ...
    'Units', 'Normalized', ...
    'Position', [0.02 0.02 0.46 0.16], ...
    'String', 'Button 1' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', f, ...
    'Units', 'Normalized', ...
    'Position', [0.52 0.02 0.46 0.16], ...
    'String', 'Button 2' );</code>
                        <result><center><img src="Images/why_normalized1.png"/>.<img src="Images/why_normalized2.png"/></center></result>
                    </example>
                    <example>
                        <description><b>2. The user-interface components stay fixed and the window resize creates empty space (pixel units)</b><br/>Although the buttons don't now grow, neither does the axes, which looks very odd.</description>
                        <code>f = <matlabfcn>figure</matlabfcn>( 'Position', 200*ones(1,4) );
<matlabfcn>axes</matlabfcn>( 'Parent', f, ...
    'Units', 'Pixels', ...
    'OuterPosition', [10 35 190 175] );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', f, ...
    'Units', 'Pixels', ...
    'Position', [5 5 90 25], ...
    'String', 'Button 1' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', f, ...
    'Units', 'Pixels', ...
    'Position', [105 5 90 25], ...
    'String', 'Button 2' );</code>
                        <result><center><img src="Images/why_fixed1.png"/>.<img src="Images/why_fixed2.png"/></center></result>
                    </example>
                </examples>
                <p>Neither of these alternatives is particularly useful for a serious
                user-interface. Typically there are user-interface components that should
                be fixed size: icons, buttons, selectors etc; and others that should resize
                with the window: graphs, images, prose text etc. To achieve this one needs
                to be able to specify which interface components should be fixed size and
                which variable. Over the last two decades, layouts have been shown to be
            the method of choice for achieving this.</p>
                <examples>
                    <example>
                        <description>Using layouts, some user-interface components scale with the window, others stay fixed</description>
                        <code>f = <matlabfcn>figure</matlabfcn>( 'Position', 200*ones(1,4) );
vbox = <fcnref>uix.VBox</fcnref>( 'Parent', f );
axes( 'Parent', vbox );
hbox = <fcnref>uix.HButtonBox</fcnref>( 'Parent', vbox, 'Padding', 5 );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', hbox, ...
    'String', 'Button 1' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', hbox, ...
    'String', 'Button 2' );
set( vbox, 'Heights', [-1 35] )</code>
                        <result><center><img src="Images/why_layout1.png"/>.<img src="Images/why_layout2.png"/></center></result>
                    </example>
                </examples>
        </subsection>
        
    </section>
    
<!-- ****************************************************************** -->
<section name="Positioning axes">
        <keywords>axes</keywords>
        <p>
            Unlike other MATLAB user interface components, <matlabfcn>axes</matlabfcn>
            have two position properties: <code>Position</code> and 
            <code>OuterPosition</code>. This means one has some extra 
            options as to how the layout will arrange the axes.
        </p>
        
        <subsection name="Position vs OuterPosition">
            <p>Typically one
                would position some axes using their <code>OuterPosition</code> so that the 
                axis labels, title and other annotations are all contained within the 
                specified area. Sometimes, particularly if drawing images, one might want 
                to instead make the axes canvas (the white bit!) fill the specified area. 
                This is done by setting the <code>Position</code> property instead.
            </p>
            
            <examples>
                <example>
                    <code><matlabfcn>figure</matlabfcn>
<matlabfcn>axes</matlabfcn>( 'Units', 'Normalized', 'OuterPosition', [0 0 1 1] )
                    </code>
                    <result><center><img src="Images/axes_outer.png"/></center></result>
                </example>
                <example>
                    <code><matlabfcn>figure</matlabfcn>
<matlabfcn>axes</matlabfcn>( 'Units', 'Normalized', 'Position', [0 0 1 1] )
                    </code>
                    <result><center><img src="Images/axes_inner.png"/></center></result>
                </example>
            </examples>
        </subsection>
        
        <subsection name="Axes inside layouts" staticref="AxesExample">
            <p>(The code for this example can be found here: 
                            [ <a href="Examples/axesexample.m">view</a>
                | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','axesexample.m'))">edit</a>
                | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); axesexample; cd(p)">run</a> ]
            )</p>
            <p>
                When using layouts to position axes, the position property
                is set by the layout, not the user. Whether the <code>Position</code>
                or <code>OuterPosition</code> property is used is determined by the
                <code>ActivePositionProperty</code> property of the <matlabfcn>axes</matlabfcn>.
                Note that the default setting is "outerposition".
            </p>
            <p>
                The following example illustrates the two usages.
            </p>
            
            <h4>Open a window</h4>
            <p>Open a new figure window and remove the toolbar and menus.</p>
            <example><code>window = <matlabfcn>figure</matlabfcn>( 'Name', 'Axes inside layouts', ...
            'MenuBar', 'none', ...
            'Toolbar', 'none', ...
            'NumberTitle', 'off' );</code>
            </example>
            <h4>Create the layout</h4>
            <p>The layout involves two axes side by side. This is done using a flexible horizontal box. The left-hand axes is left with the <code>ActivePositionProperty</code> set to "outerposition", but the right-hand axes is switched to use <code>Position</code>.</p>
            <example><code>hbox = <fcnref>uix.HBoxFlex</fcnref>('Parent', window, 'Spacing', 3);
axes1 = <matlabfcn>axes</matlabfcn>( 'Parent', hbox, ...
    'ActivePositionProperty', 'outerposition' );
axes2 = <matlabfcn>axes</matlabfcn>( 'Parent', hbox, ...
    'ActivePositionProperty', 'Position' );
set( hbox, 'Widths', [-2 -1] );</code>
             <result><center><img src="Images/axes_layout_example_2.png"/></center></result>
           </example>
           
            <h4>Fill the axes</h4>
            <p>Using <code>OuterPosition</code> (left-hand axes) is the normal mode and looks good for virtually any plot type. Using <code>Position</code> is only really useful for 2D plots with the axes turned off, such as images.</p>
            <example><code>x = membrane( 1, 15 );
<matlabfcn>surf</matlabfcn>( axes1, x );
<matlabfcn>lighting</matlabfcn>( axes1, 'gouraud' );
<matlabfcn>shading</matlabfcn>( axes1, 'interp' );
l = <matlabfcn>light</matlabfcn>( 'Parent', axes1 );
<matlabfcn>camlight</matlabfcn>( l, 'head' );
<matlabfcn>axis</matlabfcn>( axes1, 'tight' );

<matlabfcn>imagesc</matlabfcn>( x, 'Parent', axes2 );
set( axes2, 'xticklabel', [], 'yticklabel', [] );</code>
            <result><center><img src="Images/axes_layout_example_3.png"/></center></result>
            </example>
            <p></p>
        </subsection>
    
        <subsection name="Colorbars and legends" staticref="AxesLegendsColorbars">
            <p>(The code for this example can be found here: 
                            [ <a href="Examples/colorbarexample.m">view</a>
                | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','colorbarexample.m'))">edit</a>
                | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); colorbarexample; cd(p)">run</a> ]
            )</p>
            <p>
                When using layouts to position axes that can also have a
                colorbar or legend it is very important to group the axes
                with its colorbar and legend by putting them inside a <code>uicontainer</code>.
            </p>
            <p>
                The following example illustrates this.
            </p>
            
            <h4>Open a window</h4>
            <p>Open a new figure window and remove the toolbar and menus.</p>
            <example><code>window = <matlabfcn>figure</matlabfcn>( 'Name', 'Axes legend and colorbars', ...
            'MenuBar', 'none', ...
            'Toolbar', 'none', ...
            'NumberTitle', 'off' );</code>
            </example>
            
            <h4>Create the layout</h4>
            <p>The layout involves two axes side by side. Each axes is placed into a uicontainer so that the legend and colorbar are "grouped" with the axes.</p>
            <example><code>hbox = <fcnref>uix.HBoxFlex</fcnref>('Parent', window, 'Spacing', 3);
axes1 = <matlabfcn>axes</matlabfcn>( 'Parent', <matlabfcn>uicontainer</matlabfcn>('Parent', hbox) );
axes2 = <matlabfcn>axes</matlabfcn>( 'Parent', <matlabfcn>uicontainer</matlabfcn>('Parent', hbox) );</code>
             <result><center><img src="Images/colorbar_example_2.png"/></center></result>
           </example>
            
            <h4>Add decorations</h4>
            <p>Give the first axes a colorbar and the second axes a legend.</p>
            <example><code><matlabfcn>surf</matlabfcn>( axes1, <matlabfcn>membrane</matlabfcn>( 1, 15 ) );
<matlabfcn>colorbar</matlabfcn>( axes1 );
<br/>
theta = 0:360;
<matlabfcn>plot</matlabfcn>( axes2, theta, <matlabfcn>sind</matlabfcn>(theta), theta, <matlabfcn>cosd</matlabfcn>(theta) );
<matlabfcn>legend</matlabfcn>( axes2, 'sin', 'cos', 'Location', 'NorthWestOutside' );</code>
             <result><center><img src="Images/colorbar_example_3.png"/></center></result>
           </example>

       </subsection>
</section>

<!-- ****************************************************************** -->
<section name="Controlling visibility">
    <p>The examples in this section show the effect of setting the
    <code>Visible</code> property on a layout object.</p>
    
    <subsection name="Visible example" staticref="VisibleExample">
            <p>(The code for this example can be found here: 
                            [ <a href="Examples/visibleexample.m">view</a>
                | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','visibleexample.m'))">edit</a>
                | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); visibleexample; cd(p)">run</a> ]
            )</p>
       <p>
            This example shows how the <code>Visible</code> property can be
            used to hide whole sections of an interface.
        </p>
        <example>
            <description>Open a window and add a panel</description>
            <code>fig = <matlabfcn>figure</matlabfcn>( 'Name', 'Visible example', ...
    'Position', [100 100 150 250], ...
    'MenuBar', 'none', ...
    'ToolBar', 'none', ...
    'NumberTitle', 'off' );
panel = <fcnref>uix.BoxPanel</fcnref>( 'Parent', fig, 'Title', 'Panel' );</code>
            <result><center><img src="Images/VisibleExample1.png"/></center></result>
        </example>
        <example>
            <description>Put some buttons inside the panel</description>
            <code>box = <fcnref>uix.VButtonBox</fcnref>( 'Parent', panel );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 1' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 2' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 3', 'Visible', 'off' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 4' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 5', 'Visible', 'off' );
<matlabfcn>uicontrol</matlabfcn>( 'Parent', box, 'String', 'Button 6' );</code>
            <result><center><img src="Images/VisibleExample2.png"/></center></result>
        </example>
        <example>
            <description>Try hiding the panel</description>
            <code>set( panel, 'Visible', 'off' );</code>
            <result><center><img src="Images/VisibleExample3.png"/></center></result>
        </example>
        <example>
            <description>Try showing the panel. Note that the original <code>Visible</code> state of each button is remembered.</description>
            <code>set( panel, 'Visible', 'on' );</code>
            <result><center><img src="Images/VisibleExample2.png"/></center></result>
        </example>
    </subsection>
</section>
    
<!-- ****************************************************************** -->
<section name="Advanced maneuvers with panels" staticref="BoxPanelFancyStuff">
    <p>
        The <fcnref>uix.BoxPanel</fcnref> provides some extra buttons
        and callbacks that can be used to design advanced user-interface
        layouts. In particular, the sections below illustrate how to create
        interfaces with context help, and panels that can be minimized or undocked.
    </p>
    
    <subsection name="Context help" staticref="PanelHelp">
        <p>
            When a <fcnref>uix.BoxPanel</fcnref> has its <code>HelpFcn</code> 
            filled in, a help button (?) is shown in the upper-right of the
            title-bar. When the user clicks this button the specified function
            is called.
        </p>
        <examples>
            <example>
                <description>Here we hookup the HelpFcn to simply bring up
            the MATLAB documentation for each command. Clicking any of the "?" buttons
        will cause the MATLAB help browser to open.</description>
                <code>f = <matlabfcn>figure</matlabfcn>( 'Name', 'uix.BoxPanel Help Example' );
b = <fcnref>uix.HBox</fcnref>( 'Parent', f );
<fcnref>uix.BoxPanel</fcnref>( 'Parent', b, 'Title', 'sin', 'HelpFcn', @(a,b) doc('sin') );
<fcnref>uix.BoxPanel</fcnref>( 'Parent', b, 'Title', 'cos', 'HelpFcn', @(a,b) doc('cos') );
<fcnref>uix.BoxPanel</fcnref>( 'Parent', b, 'Title', 'tan', 'HelpFcn', @(a,b) doc('tan') );
</code>
                <result><center><img src="Images/BoxPanelHelpExample.png"/></center></result>
            </example>
        </examples>
        
    </subsection>
    
    <subsection name="Minimize and maximize" staticref="PanelMinimize">
        <p>
            When a <fcnref>uix.BoxPanel</fcnref> has its <code>MinimizeFcn</code> 
            filled in, a minimize/maximize button (&#9652;/&#9662;) is shown in the upper-right of the
            title-bar. When the user clicks this button the specified function
            is called. Since the behaviour of the parent container is
            different in different use-cases, it is up to the user to write
            some code to actually resize the panel. Note that minimizing
            a panel to its title-bar only really makes sense inside a 
            <fcnref>uix.VBox</fcnref> or <fcnref>uix.VBoxFlex</fcnref>.
                 </p>
                 <p>The following simple example shows how to add minimize/maximize
                     functionality to a box full of panels. Save the code into
                 a file called "minimizeexample.m" to run it.</p>
                 
                 <p>(The code for this example can be found here: 
                     [ <a href="Examples/minimizeexample.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','minimizeexample.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); minimizeexample; cd(p)">run</a> ]
                 )</p>
                 
                 
                 <h4>Create the layout with three panels</h4>
            <p>Open a new figure window and add three panels.</p>
            <example><code><matlabfcn>function</matlabfcn> minimizeexample()
width = 200;
pheightmin = 20;
pheightmax = 100;

<comment>% Create the window and main layout</comment>
fig = <matlabfcn>figure</matlabfcn>( <string>'Name'</string>, <string>'Collapsable GUI example'</string>, ...
              <string>'NumberTitle'</string>, <string>'off'</string>, ...
              <string>'Toolbar'</string>, <string>'none'</string>, ...
              <string>'MenuBar'</string>, <string>'none'</string> );
box = <fcnref>uix.VBox</fcnref>( 'Parent', fig );

panel{1} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 1'</string>, <string>'Parent'</string>, box );
panel{2} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 2'</string>, <string>'Parent'</string>, box );
panel{3} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 3'</string>, <string>'Parent'</string>, box );
<matlabfcn>set</matlabfcn>( box, 'Heights', pheightmax*ones(1,3) );

<comment>% Add some contents</comment>.
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 1'</string>, <string>'Parent'</string>, panel{1} );
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 2'</string>, <string>'Parent'</string>, panel{2} );
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 3'</string>, <string>'Parent'</string>, panel{3} );

<comment>% Resize the window</comment>
pos = <matlabfcn>get</matlabfcn>( fig, <string>'Position'</string> );
<matlabfcn>set</matlabfcn>( fig, <string>'Position'</string>, [pos(1,1:2),width,sum(box.Heights)] );</code>
            <result><center><img src="Images/BoxPanelMinimizeExample1.png"/></center></result>
        </example>
        
            <h4>Add the minimize/maximize callback</h4>
            <p>We set each panel to call the same minimize/maximize function.
        This function is nested inside the main function so that it has access
    to the main function's variables. A better way to do this is to make the
main function into a class, but this nested-function approach is fine
for simple applications.</p>
            <p>Note that as soon as we set the "MinimizeFcn" property the minimize/maximize
                icon appears in the top-right of each panel. We use a cell-array to pass an
            extra argument, the panel number, to the minimize function. This extra argument appears after the usual
            <code>eventSource</code> and <code>eventData</code> arguments.</p>
            <example><code><comment>% Hook up the minimize callback</comment>.
<matlabfcn>set</matlabfcn>( panel{1}, <string>'MinimizeFcn'</string>, {@nMinimize, 1} );
<matlabfcn>set</matlabfcn>( panel{2}, <string>'MinimizeFcn'</string>, {@nMinimize, 2} );
<matlabfcn>set</matlabfcn>( panel{3}, <string>'MinimizeFcn'</string>, {@nMinimize, 3} );

<comment>%-------------------------------------------------------------------------%</comment><br/> 
    <matlabfcn>function</matlabfcn> nMinimize( eventSource, eventData, whichpanel )
        <comment>% A panel has been maximized/minimized</comment>
        s = <matlabfcn>get</matlabfcn>( box, <string>'Heights'</string> );
        pos = <matlabfcn>get</matlabfcn>( fig, <string>'Position'</string> );
        panel{whichpanel}.Minimized = ~panel{whichpanel}.Minimized;
        <matlabfcn>if</matlabfcn> panel{whichpanel}.Minimized
            s(whichpanel) = pheightmin;
        <matlabfcn>else</matlabfcn>
            s(whichpanel) = pheightmax;
        <matlabfcn>end</matlabfcn>AMPnbsp;
        <matlabfcn>set</matlabfcn>( box, <string>'Heights'</string>, s );
        
        <comment>% Resize the figure, keeping the top stationary</comment>
        delta_height = pos(1,4) - <matlabfcn>sum</matlabfcn>( box.Heights );
        <matlabfcn>set</matlabfcn>( fig, <string>'Position'</string>, pos(1,:) + [0 delta_height 0 -delta_height] );
    <matlabfcn>end</matlabfcn>AMPnbsp;<comment>% Minimize</comment>AMPnbsp;

<matlabfcn>end</matlabfcn>AMPnbsp;<comment>% Main function</comment></code>
            <result><center><img src="Images/BoxPanelMinimizeExample2.png"/></center></result>
        </example>
        
    
            <h4>Click the minimize buttons</h4>
            <p>Minimizing the middle panel causes it to shrink to just its 
            title-bar and the window shrinks accordingly. The
    "Minimize" icon is replaced by a "Maximise" icon.</p>
            <example><result><center><img src="Images/BoxPanelMinimizeExample3.png"/></center></result></example>
            <p> Re-maximizing the panel would
            cause it to re-appear in full and the window to grow again.</p>

        </subsection>
        
    <subsection name="Dock and undock" staticref="PanelDock">
        <keywords>Undock</keywords>
        <p>
            When a <fcnref>uix.BoxPanel</fcnref> has its <code>DockFcn</code> 
            filled in, a dock/undock button (&#8600;/&#8599;) is shown in the upper-right of the
            title-bar. When the user clicks this button the specified function
            is called. Since re-docking the panel into its previous parent
            depends on the type of parent, it is up to the user to write
            some code to actually extract or insert the panel.
        </p>
             <p>The following simple example shows how to add dock/undock
                 functionality to a box full of panels. Save the code into
                 a file called "dockexample.m" to run it.</p>
                 
                 <p>(The code for this example can be found here: 
                     [ <a href="Examples/dockexample.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','dockexample.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); dockexample; cd(p)">run</a> ]
                 )</p>
       
            <h4>Create the layout with three panels</h4>
            <p>Open a new figure window and add three panels.</p>
            <example><code><matlabfcn>function</matlabfcn> dockexample()
<comment>% Create the window and main layout</comment>
fig = <matlabfcn>figure</matlabfcn>( <string>'Name'</string>, <string>'Dockable GUI example'</string>, ...
              <string>'NumberTitle'</string>, <string>'off'</string>, ...
              <string>'Toolbar'</string>, <string>'none'</string>, ...
              <string>'MenuBar'</string>, <string>'none'</string>, ...
              <string>'CloseRequestFcn'</string>, @nCloseAll );
box = <fcnref>uix.HBox</fcnref>( <string>'Parent'</string>, fig );

<comment>% Add three panels to the box</comment>
panel{1} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 1'</string>, <string>'Parent'</string>, box );
panel{2} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 2'</string>, <string>'Parent'</string>, box );
panel{3} = <fcnref>uix.BoxPanel</fcnref>( <string>'Title'</string>, <string>'Panel 3'</string>, <string>'Parent'</string>, box );

<comment>% Add some contents</comment><br/>
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 1'</string>, <string>'Parent'</string>, panel{1} );
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 2'</string>, <string>'Parent'</string>, panel{2} );
<matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, <string>'String'</string>, <string>'Button 3'</string>, <string>'Parent'</string>, panel{3} );</code>
            <result><center><img src="Images/BoxPanelDockExample1.png"/></center></result>
        </example>
        
            <h4>Add the dock/undock callback</h4>
            <p>We set each panel to call the same dock/undock function.
        This function is nested inside the main function so that it has access
    to the main function's variables. A better way to do this is to make the
main function into a class, but this nested-function approach is fine
for simple applications.</p>
            <p>Note that as soon as we set the "DockFcn" property the Dock/Undock
                icon appears in the top-right of each panel. We use a cell-array to pass an
            extra argument, the panel number, to the minimize function. This extra argument appears after the usual
            <code>eventSource</code> and <code>eventData</code> arguments.</p>
            <example><code><comment>% Set the dock/undock callback</comment><br/>
<matlabfcn>set</matlabfcn>( panel{1}, <string>'DockFcn'</string>, {@nDock, 1} );
<matlabfcn>set</matlabfcn>( panel{2}, <string>'DockFcn'</string>, {@nDock, 2} );
<matlabfcn>set</matlabfcn>( panel{3}, <string>'DockFcn'</string>, {@nDock, 3} );

<comment>%-------------------------------------------------------------------------%</comment><br/> 
    <matlabfcn>function</matlabfcn> nDock( eventSource, eventData, whichpanel )
        <comment>% Set the flag</comment>
        panel{whichpanel}.Docked = ~panel{whichpanel}.Docked;
        <matlabfcn>if</matlabfcn> panel{whichpanel}.Docked
            <comment>% Put it back into the layout</comment>
            newfig = <matlabfcn>get</matlabfcn>( panel{whichpanel}, <string>'Parent'</string> );
            <matlabfcn>set</matlabfcn>( panel{whichpanel}, <string>'Parent'</string>, box );
            <matlabfcn>delete</matlabfcn>( newfig );
        <matlabfcn>else</matlabfcn>AMPnbsp;
            <comment>% Take it out of the layout</comment>
            pos = <matlabfcn>getpixelposition</matlabfcn>( panel{whichpanel} );
            newfig = <matlabfcn>figure</matlabfcn>( ...
                <string>'Name'</string>, <matlabfcn>get</matlabfcn>( panel{whichpanel}, <string>'Title'</string> ), ...
                <string>'NumberTitle'</string>, <string>'off'</string>, ...
                <string>'MenuBar'</string>, <string>'none'</string>, ...
                <string>'Toolbar'</string>, <string>'none'</string>, ...
                <string>'CloseRequestFcn'</string>, {@nDock, whichpanel} );
            figpos = <matlabfcn>get</matlabfcn>( newfig, <string>'Position'</string> );
            <matlabfcn>set</matlabfcn>( newfig, <string>'Position'</string>, [figpos(1,1:2), pos(1,3:4)] );
            <matlabfcn>set</matlabfcn>( panel{whichpanel}, <string>'Parent'</string>, newfig, ...
                <string>'Units'</string>, <string>'Normalized'</string>, ...
                <string>'Position'</string>, [0 0 1 1] );
        <matlabfcn>end</matlabfcn>AMPnbsp;
    <matlabfcn>end</matlabfcn>AMPnbsp;<comment>% nDock</comment></code></example>

        
            <h4>Add the close callback</h4>
            <p>If the user closes the main window we need to also close any
            other windows that were created. This can be done by finding 
            the window that contains each panel and deleting it.</p>
            <example><code><comment>%-------------------------------------------------------------------------%</comment><br/> 
   <matlabfcn>function</matlabfcn> nCloseAll( ~, ~ )
      <matlabfcn>for</matlabfcn> ii=1:<matlabfcn>numel</matlabfcn>( panel )
         <matlabfcn>if</matlabfcn> <matlabfcn>isvalid</matlabfcn>( panel{ii} ) AMPAMP ~<matlabfcn>strcmpi</matlabfcn>( panel{ii}.BeingDeleted, <string>'on'</string> )
            figh = <matlabfcn>ancestor</matlabfcn>( panel{ii}, <string>'figure'</string> );
            <matlabfcn>delete</matlabfcn>( figh );
         <matlabfcn>end</matlabfcn>AMPnbsp;
      <matlabfcn>end</matlabfcn>AMPnbsp;
        
   <matlabfcn>end</matlabfcn>AMPnbsp;<comment>% nCloseAll</comment>
<matlabfcn>end</matlabfcn>AMPnbsp;<comment>% Main function</comment></code>
            <result><center><img src="Images/BoxPanelDockExample2.png"/></center></result>
        </example>
        
            <h4>Click the dock buttons</h4>
            <p>Undocking the middle panel causes the other two to fill the
        vacated space. The undocked panel appears in its own window, with the
    "Undock" icon replaced by a "Dock" icon.</p>
            <example><result><center><img src="Images/BoxPanelDockExample3.png"/>.<img src="Images/BoxPanelDockExample4.png"/></center></result></example>
            <p> Re-docking the panel would
            cause it to be appended to the right of the list in the original window. Closing the main window
        causes all panels, docked or undocked, and their enclosing windows to be closed.</p>
</subsection>
    
</section>

    <!-- ****************************************************************** -->
    <section name="Using layouts inside GUIDE GUIs" staticref="LayoutsGUIDE">
        <keywords>GUIDE</keywords>
        <p>Whilst the layouts in this toolbox do not integrate into the
        MATLAB Graphical User Interface Design Environment (<matlabfcn>GUIDE</matlabfcn>), it
    is possible to insert layouts into a GUIDE-built GUI as follows:</p>
        <h4>Create the GUIDE GUI</h4>
            <p>Create you GUIDE application as usual, placing a panel where you
        want to insert the layout. You can turn the panel border and title
    off if you do not want them.</p>
        <center><img src="Images/guide1.png"/></center>

        <h4>Insert the layout</h4>
        <p>Edit the "OpeningFcn" in the GUIDE-created code and insert your
    layout into the panel, making it fill the space. In the example below
four boxpanels are inserted into a grid, which itself is placed inside
        <code>uipanel1</code>:</p>
        <example>
            <code><comment>% --- Executes just before guideApp is made visible.</comment>AMPnbsp;
<matlabfcn>function</matlabfcn> guideApp_OpeningFcn(hObject, eventdata, handles, varargin)

<comment>% Choose default command line output for guideApp</comment>AMPnbsp;
handles.output = hObject;

<comment>% Update handles structure</comment>AMPnbsp;
guidata(hObject, handles);

<comment>% Put a layout in the panel</comment>AMPnbsp;
g = <fcnref>uix.GridFlex</fcnref>( <string>'Parent'</string>, handles.uipanel1, ...
    <string>'Units'</string>, <string>'Normalized'</string>, <string>'Position'</string>, [0 0 1 1], ...
    <string>'Spacing'</string>, 5 );
<fcnref>uix.BoxPanel</fcnref>( <string>'Parent'</string>, g, <string>'Title'</string>, <string>'Panel 1'</string> );
<fcnref>uix.BoxPanel</fcnref>( <string>'Parent'</string>, g, <string>'Title'</string>, <string>'Panel 2'</string> );
<fcnref>uix.BoxPanel</fcnref>( <string>'Parent'</string>, g, <string>'Title'</string>, <string>'Panel 3'</string> );
<fcnref>uix.BoxPanel</fcnref>( <string>'Parent'</string>, g, <string>'Title'</string>, <string>'Panel 4'</string> );
g.Heights = [-1 -1];</code>
            <result><center><img src="Images/guide2.png"/></center></result>
        </example>
                         <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/guideApp.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','guideApp.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); guideApp; cd(p)">run</a> ]
                 )</small></p>

    </section>

    <!-- ****************************************************************** -->
    <section name="Deploying GUIs using the MATLAB Compiler" staticref="Compiling">
        <keywords>Compiler</keywords>
        <keywords>MATLAB Compiler</keywords>
        <p>Applications built using these layout tools can be deployed as standalone
            executables using the <a href="matlab:doc compiler">MATLAB Compiler</a> in
        the same way as any other MATLAB application. There is, however, one thing to watch out for:</p>
        <ul>
            <li>You must explicitly include the "Resources" folder within the +uix package</li>
        </ul>
        <h4>Example</h4>
        <p>Below is a screen-shot of the <matlabfcn>deploytool</matlabfcn> setup
        used to build the <ref link="ExampleApp">example application</ref>.
    The "Resources" folder from the toolbox has been explicitly added as a
shared resource so that the mouse-pointers and panel icons continue to work.</p>
        <example><result><center><img src="Images/deploy.png"/></center></result></example>
    </section>
        
        
        
        

    <!-- ****************************************************************** -->
    <section name="A complete example" staticref="ExampleApp">
        <keywords>Callbacks</keywords>
        <keywords>Application design</keywords>
<img src="Images/demoBrowser4.png" align="right"/>
        <p>The following example application uses many of the layout features
            discussed above in order to create a good-looking user interface that
        scales well when resized. It is not designed to showcase all the
        layout functionality, but shows how callbacks are added to provide
        user interaction. It also exemplifies separating the data from the GUI,
    a fundamental part of creating modular and maintainable applications.</p>
        <p>The full application is available here:</p>
        <ul>
            <li><a href="Examples/demoBrowser.m">View demoBrowser.m</a></li>
            <li><a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">Edit demoBrowser.m</a></li>
            <li><a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples'));demoBrowser;cd(p)">Run demoBrowser.m</a></li>
        </ul>

        
        
        <subsection name="Application structure" staticref="demoBrowserStructure">

        <p>There are many ways to build graphical applications in MATLAB, but
    here we will take a very simple approach. If the application were to become
larger and more complex, this approach would be changed to better mitigate
    the complexity. Some notes on this are contained <ref link="demoBrowserScalability">at the end</ref>.</p>

    <p>The application is structured as a single function with callbacks and other helper
        functions stored as "nested" subfunctions, i.e. functions inside the main function. This has
        the advantage that the nested subfunctions can share access to any variables
        declared in the main function. This is also a risk as anything we accidentally
        declare in the main function becomes "global" within the application. For that reason
        <em>all</em> logic is put into subfunctions and we restrict the main
    function to just declaring two shared variables:</p>
    <ul>
        <li><b>data</b>: a structure containing all shared data</li>
        <li><b>gui</b>: a structure containing handles to GUI widgets</li>
    </ul>
    <example><code>
<matlabfcn>function</matlabfcn> demoBrowser()

   <comment>% Declare shared variables</comment>
   data = createData();
   gui = createInterface( data.DemoNames );

   <comment>% Now update the GUI with the current data</comment>
   updateInterface();
   redrawDemo();
   
   <comment>% Helper subfunctions</comment>.
   <matlabfcn>function</matlabfcn> data = createData() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> gui = createInterface(names) ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> updateInterface() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> redrawDemo() ... <matlabfcn>end</matlabfcn>;

   <comment>% Callback subfunctions</comment>.
   <matlabfcn>function</matlabfcn> onMenuSelection() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> onListSelection() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> onDemoHelp() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> onHelp() ... <matlabfcn>end</matlabfcn>;
   <matlabfcn>function</matlabfcn> onExit() ... <matlabfcn>end</matlabfcn>;

<matlabfcn>end</matlabfcn> <comment> % Main function</comment>
</code></example>

<p>Note that all of the work is done in subfunctions. Most subfunctions
are callbacks executed when a button is pressed or a menu selected. The four used
at startup are helper functions:</p>
    <ul>
        <li><b>createData</b>: build the structure which contains all application data</li>
        <li><b>createInterface</b>: build the user interface</li>
        <li><b>updateInterface</b>: update selectors etc in response to a change in the data</li>
        <li><b>redrawDemo</b>: redraw the plot part of the interface</li>
    </ul>
    <p>We will not dig into all the subfunctions and callbacks, but instead
        concentrate on the GUI creation (<ref link="demoBrowserCreateInterface">createInterface</ref>)
        and update (<ref link="demoBrowserUpdateInterface">updateInterface</ref>).</p>
    
                 <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/demoBrowser.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); demoBrowser; cd(p)">run</a> ]
                 )</small></p>
</subsection>

<subsection name="createInterface" staticref="demoBrowserCreateInterface">
    <p>The interface creation is handled in the <code>createInterface</code>
        subfunction. This has two distinct sections: menu building and widget arrangement.
        The menus are built using the standard MATLAB menu building command <matlabfcn>uimenu</matlabfcn>,
    so let's concentrate on the widget arrangement.</p>

    <p>The top-level layout is a horizontal arrangement, placing the controls
to the left of the main plot. We make the layout draggable by using the
"flex" variant of HBox, and put a panel in each side. Note that setting the
"HelpFcn" for the view panel adds a small "?" icon for bringing up help. See
<ref link="PanelHelp">here</ref> for more details.</p>
<example><code>
<comment>% Add the contents</comment>
mainLayout = <fcnref>uix.HBoxFlex</fcnref>( <string>'Parent'</string>, gui.Window, <string>'Spacing'</string>, 3 );

<comment>% Create the panels</comment>
controlPanel = <fcnref>uix.BoxPanel</fcnref>( ...
   <string>'Parent'</string>, mainLayout, ...
   <string>'Title'</string>, <string>'Select a demo:'</string> );
gui.ViewPanel = <fcnref>uix.BoxPanel</fcnref>( ...
   <string>'Parent'</string>, mainLayout, ...
   <string>'Title'</string>, <string>'Viewing: ???'</string>, ...
   <string>'HelpFcn'</string>, @onDemoHelp );

<comment>% Adjust the main layout</comment><br/>
<matlabfcn>set</matlabfcn>( mainLayout, <string>'Widths'</string>, [-1,-2]  );
    </code>
    <result><center><img src="Images/demoBrowser1.png"/></center></result>
</example>
<p>The controls panel is filled with a vertical layout containing the listbox
and a button. Note the callbacks that are specified for both the list and button. These
both call further subfunctions that are able to access the common "data" and "gui"
shared structures.</p>
<example><code>
<comment>% Create the controls</comment>
controlLayout = <fcnref>uix.VBox</fcnref>( <string>'Parent'</string>, controlPanel, ...
   <string>'Padding'</string>, 3, <string>'Spacing'</string>, 3 );
gui.ListBox = <matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'list'</string>, ...
   <string>'BackgroundColor'</string>, <string>'w'</string>, ...
   <string>'Parent'</string>, controlLayout, ...
   <string>'String'</string>, demoList(:), ...
   <string>'Value'</string>, 1, ...
   <string>'Callback'</string>, @onListSelection);
gui.HelpButton = <matlabfcn>uicontrol</matlabfcn>( <string>'Style'</string>, <string>'PushButton'</string>, ...
   <string>'Parent'</string>, controlLayout, ...
   <string>'String'</string>, <string>'Help for &lt;demo&gt;'</string>, ...
   <string>'Callback'</string>, @onDemoHelp );
<matlabfcn>set</matlabfcn>( controlLayout, <string>'Heights'</string>, [-1 28] ); <comment>% Make the list fill the space</comment>
</code>
<result><center><img src="Images/demoBrowser2.png"/></center></result>
</example>
<p>Finally, the view itself is simply an axes placed inside the view panel:</p>   
<example><code>
<comment>% Create the view</comment>
gui.ViewAxes = <matlabfcn>axes</matlabfcn>( <string>'Parent'</string>, gui.ViewPanel );
   </code>
   <result><center><img src="Images/demoBrowser3.png"/></center></result>
</example>
                 <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/demoBrowser.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); demoBrowser; cd(p)">run</a> ]
                 )</small></p>
    </subsection>

    <subsection name="updateInterface" staticref="demoBrowserUpdateInterface">
        <p>The second subfunction we will look at, <code>updateInterface</code>, uses the
            current selections to update the interface. This uses the structure
            "data" to update various parts of the interface. For this simple example this just means:
        </p>
        <p><b>1. Update the selected item in the listbox</b></p>
        <example><code>set( gui.ListBox, <string>'Value'</string>, data.SelectedDemo );</code></example>
        <p><b>2. Update the help button label</b></p>
        <example><code>demoName = data.DemoNames{ data.SelectedDemo };<br/><matlabfcn>set</matlabfcn>( gui.HelpButton, <string>'String'</string>, [<string>'Help for '</string>,demoName] );</code></example>
        <p><b>3. Update the view panel title</b></p>
        <example><code><matlabfcn>set</matlabfcn>( gui.ViewPanel, <string>'Title'</string>, <matlabfcn>sprintf</matlabfcn>( <string>'Viewing: %s'</string>, demoName ) );</code></example>
        <p><b>4. Update the ticked menu</b></p>
        <example><code>menus = <matlabfcn>get</matlabfcn>( gui.ViewMenu, <string>'Children'</string> );
<matlabfcn>set</matlabfcn>( menus, <string>'Checked'</string>, <string>'off'</string> );
<comment>% Use the name to work out which menu item should be ticked</comment>
whichMenu = <matlabfcn>strcmpi</matlabfcn>( demoName, <matlabfcn>get</matlabfcn>( menus, <string>'Label'</string> ) );
<matlabfcn>set</matlabfcn>( menus(whichMenu), <string>'Checked'</string>, <string>'on'</string> );
</code></example>
        <example><result><center><img src="Images/demoBrowser4.png"/></center></result></example>
        <p>In general, this update function is called whenever the underlying
            shared "data" structure is changed. This happens when the user clicks
            a button, selects a list item or a menu. Next we will look at a typical
        callback.</p>
                 <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/demoBrowser.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); demoBrowser; cd(p)">run</a> ]
                 )</small></p>
    </subsection>

        <subsection name="onListSelection" staticref="demoBrowserOnListSelection">
            <p>Finally, let's have a look at how one of the callbacks works: "onListSelection", the function
        that is called when an item is selected in the listbox. The other
            callbacks obey the same pattern.</p>
            <p>The basic rule of thumb is that a callback should not update any part of
        the user interface directly - it's job is to respond to user interaction by changing the "data" structure. 
        In this example, each callback changes the underlying data structure
    then asks the interface to refresh. This might mean that things update in the
interface that don't need to, but ensures the callbacks remain simple and that all
interface update logic is in one place. Extending this to more granular interface updates
            is straightforward. See <ref link="demoBrowserScalability">Scalability</ref> for more details.</p>
            <p>For the listbox callback, the "src" argument is a handle to the
            listbox and we simply need to update the SelectedDemo field of "data"
            to reflect the new selection. We then ask the rest of the interface to
            update in response to the change.
            </p>
            <example><code>
                <comment>% User selected a demo from the list - update "data" and refresh</comment>
data.SelectedDemo = <matlabfcn>get</matlabfcn>( src, <string>'Value'</string> );
updateInterface();
redrawDemo();</code>
        <result><center><img src="Images/demoBrowser4.png"/></center></result>
        </example>
                 <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/demoBrowser.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); demoBrowser; cd(p)">run</a> ]
                 )</small></p>
        </subsection>

        <subsection name="Running it" staticref="demoBrowserRun">
            <p>When the main function is launched (click 
                <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples'));demoBrowser;cd(p)">here</a>)
                it first creates the data, then the GUI, then updates the GUI using the data. At this point the
                function exits and control is returned to the command prompt. Note, however,
            that the GUI is still onscreen and will still respond to user interaction.</p>
            <p>This works because the "shared" variables in the main function are not cleared when the
                function exits. They are only cleared once the GUI is closed. This is a slightly
                unusual, but very useful, feature of using nested functions for building
            applications.</p>
            <examples>
                <example>
                <code>&gt;&gt; demoBrowser</code>
                <result><center><img src="Images/demoBrowser4.png"/></center></result>
                </example>
            </examples>
                 <p><small>(Full source code for this application is available here: 
                     [ <a href="Examples/demoBrowser.m">view</a>
                     | <a href="matlab: edit(fullfile(layoutDocRoot,'Examples','demoBrowser.m'))">edit</a>
                     | <a href="matlab: p=pwd();cd(fullfile(layoutDocRoot,'Examples')); demoBrowser; cd(p)">run</a> ]
                 )</small></p>
        </subsection>
        
        <subsection name="Scalability" staticref="demoBrowserScalability">
            <p>As applications get bigger the code gets more complex. The simple
                application structure used here does not scale well to large applications,
            however some small adjustments can make life much better:</p>
            <ul>
                <li>Convert the "data" structure into a <a href="matlab: doc handle">handle object</a>. This allows
                    a single "data" object to be shared between mutliple graphical interfaces, and in turn means that the interface
                need not be built as a single monolithic entity.</li>
                <li>Use the <a href="matlab: doc event.listener">events system</a> to trigger updates
                    to specific parts of the GUI in response to bits of the data object changing. This removes the need
                for a single large "UpdateInterface" function and reduces coupling between parts of the interface. For example,
            the "SelectedDemo" property would have an associated event such that when it is changed by a callback (or from the command-line) it
        notifies other interface components of the change. Each interface component (or group thereof) can
    just listen for the events that affect it.</li>
            </ul>
            <p>Advice on how to build large-scale applications is beyond the scope
                of this document. If you need help in this area, please contact your MathWorks
            account manager who will be able to put you in touch with a technical specialist.</p>
        </subsection>
    </section>
<!-- ****************************************************************** -->
</doc>
